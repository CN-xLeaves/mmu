## 1. 项目简介

#### 1.1 基础简介

MMU 为 Memory Management Unit 的缩写（和CPU里面的内存管理单元不是同一个用途），最初用在我个人的项目中，方便高效易用的管理各类结构体内存，我个人比较喜欢用纯C开发，每个工程组织各种数据的时候，都需要各类内存管理器和数据结构，帮我解决数据管理的难题，久而久之就积累了一些基础代码。

后来我要开发自己的编程语言 xLang 了，对数据的管理需求更加迫切，在参考了多个脚本语言的内存管理部分代码后，始终觉得不够满意，于是决定将过去开发的几个模块，加上未来可能的新需求，整合为一个功能完备的内存管理器，因为一开始这个库只有很少的功能，因此叫内存管理单元，后来随着功能慢慢集成进来，这个名字也就没再改过。

#### 1.2 功能范围

目前 MMU 库提供了 21 种功能，用于管理各种形态的数据，主要是管理各种长度固定的结构体、数据指针等。

我认为组织大量数据的基础，在于对各种表格和树状结构的管理，表格在C语言种的体现即结构体数组，但C语言对数组的支持非常基础，增删改查等操作都需要自己实现，比较麻烦，而且性能也不高，MMU 的出现就是为了辅助管理各种结构体数据和指针数据（结构体、数据管理器相互引用，需要用到指针管理器）。

未来还会继续提供数种乃至数十种数据结构管理器，方便应对各类项目的挑战。

一些功能是重合的，例如哈希表提供了32位、64位和基于AVLTree和RBTree的组合实现，一共4种，这样做是为了方便最终用户根据自己的业务需要取舍，选择现有的模块直接使用。

#### 1.3 设计原则

MMU 库是性能优先的，在我能力范围内，尽可能的优化各类数据结构的运行速度，我始终坚信，基础库留出最大的性能冗余，高层建筑才能稳固搭建，不至于某天因为一些瓶颈而轰然倒塌，代码中使用的第三方功能实现（rpmalloc、nmhash32x、rapidhash 也是经过了充分基准测试，优中选优，确保具备足够强的性能）。

MMU 设计了高效运行的内存池，可以非常快速的申请和释放结构体内存，几乎所有管理器都自带缓冲机制，可以避免重复申请内存带来的性能损耗，通过牺牲一定的内存空间提升运行效率（但 MMU 仍是相当节约内存的）。

MMU 集成了 rpmalloc 管理动态大小的内存，可以大幅提升 malloc 的运行效率。

MMU 库是非常易于集成的，受肖恩·巴雷特的影响，我在过去也经常使用基于头文件分享代码模块的方式进行开发，个人认为用于分发的库应该组织结构清晰，集成只需要一个头文件，最多需要一个 .c 代码文件和一个头文件即可完成，编译容易不使用 make 工具，不需要考虑编译器环境，不需要在编译过程中解决各类奇怪的报错，为使用带来过多负担是更好的开源标准。

MMU 库是可裁剪的，按照自己的使用需求，通过宏定义来开启对应的功能，而不需要因为使用一个最基础的功能，被迫将一大堆垃圾代码都编译到自己的程序里，让编译后的程序莫名其妙的体积膨胀。

#### 1.4 项目集成

想在你的工程中集成 mmu 模块，有两个方式：

##### 集成方案 1 ：

编译列表添加 mmu.c
将 mmu_config.h 和 mmu.h 放在 mmu.c 同目录
修改 mmu_config.h 文件，根据需要裁剪自己保留的功能
自己的代码引用 mmu.h
使用 mmu 库，编译自己的程序检查是否正常

##### 集成方案 2 ：

将 mmu_single.h 添加到自己的代码目录
自己的代码引用 mmu_single.h
在引用 mmu_single.h 之前，按照 mmu_config.h 里的宏定义提前定义各种功能的裁剪开关
使用 mmu 库，编译自己的程序检查是否正常

#### 1.5 已知缺陷

目前 MMU 还不是线程安全的，在多线程环境下使用各种数据管理器，需要自己加锁，未来可能会考虑增加这部分功能。

## 2. 功能裁剪定制

	MMU_USE_RPMALLOC
		定义后，调用 mmu_realloc、mmu_malloc、mmu_calloc、mmu_free 将替换使用 rpmalloc 库函数
	
	MMU_USE_SMMU
		定义后可使用 SMMU 模块 - Struct Memory Management Unit [结构体内存管理单元]
	
	MMU_USE_PMMU
		定义后可使用 PMMU 模块 - Point Memory Management Unit [指针内存管理单元]
	
	MMU_USE_MBMU
		定义后可使用 MBMU 模块 - Memory Buffer Management Unit [内存缓冲区管理单元]
	
	MMU_USE_MMU256
		定义后可使用 MMU256 模块 - Memory Management Unit 256 [固定 256 个数量的内存管理单元]
	
	MMU_USE_MMU64K
		定义后可使用 MMU64K 模块 - Memory Management Unit 64K [固定 65536 个数量的内存管理单元]
	
	MMU_USE_MM256
		定义后可使用 MM256 模块 - Memory Management 256 [内存管理器（固定大小的内存池，使用 MMU256 加速分配和释放）]
	
	MMU_USE_MM64K
		定义后可使用 MM64K 模块 - Memory Management 64K [内存管理器（固定大小的内存池，使用 MMU64K 加速分配和释放）]
	
	MMU_USE_SSSTK
		定义后可使用 SSSTK 模块 - Struct Static Stack [结构体静态栈，初始化时申请内存，栈最大深度固定]
	
	MMU_USE_PSSTK
		定义后可使用 PSSTK 模块 - Point Static Stack [指针静态栈，初始化时申请内存，栈最大深度固定]
	
	MMU_USE_SDSTK
		定义后可使用 SDSTK 模块 - Struct Dynamic Stack [结构体动态栈，结构体内存256个递增，栈最大深度不固定]
	
	MMU_USE_PDSTK
		定义后可使用 PDSTK 模块- Point Dynamic Stack [指针动态栈，结构体内存256个递增，栈最大深度不固定]
	
	MMU_USE_LLIST
		定义后可使用 LLIST 模块 - Linked List 双向链表 [使用 MM256 管理内存]
	
	MMU_USE_AVLTREE
		定义后可使用 AVLTREE 模块 - AVLTree AVL树 [使用 MM256 管理内存]
	
	MMU_USE_RBTREE
		定义后可使用 RBTREE 模块 - Red Black Tree 红黑树 [使用 MM256 管理内存]
	
	MMU_USE_HASH32
		定义后可使用 HASH32 模块 - nmhash32x Ver 2.0 哈希算法
	
	MMU_USE_HASH64
		定义后可使用 HASH64 模块 - rapidhash Ver 1.0 哈希算法
	
	MMU_USE_AVLHT32
		定义后可使用 AVLHT32 模块 - 基于 AVLTree 和 32 位长度哈希值实现的哈希表
	
	MMU_USE_AVLHT64
		定义后可使用 AVLHT64 模块 - 基于 AVLTree 和 64 位长度哈希值实现的哈希表
	
	MMU_USE_RBHT32
		定义后可使用 RBHT32 模块 - 基于 RBTree 和 32 位长度哈希值实现的哈希表
	
	MMU_USE_RBHT64
		定义后可使用 RBHT64 模块 - 基于 RBTree 和 64 位长度哈希值实现的哈希表
	
	MMU_USE_CSQUE（未实现）
		定义后可使用 CSQUE 模块 - Circular Sequence Queue 循环顺序队列
	
	MMU_USE_EEQUE（未实现）
		定义后可使用 EEQUE 模块 - Elastic Expansion Queue 弹性扩展队列 [使用 MM256 管理内存]
	
	MMU_USE_PRQUE（未实现）
		定义后可使用 PRQUE 模块 - Priority Queue 优先级队列 [使用红黑树实现]
	
	MMU_USE_DGRAPH（未实现）
		定义后可使用 DGRAPH 模块 - Directed Graph 单向图结构
	
	MMU_USE_UGRAPH（未实现）
		定义后可使用 UGRAPH 模块 - Undirected Graph 双向图结构
	
	MMU_USE_DOM（未实现）
		定义后可使用 DOM 模块 - Document Object Model 文档对象模型

## 3. rpmalloc

rpmalloc 是通用内存管理模块，单独使用时可理解为变长内存池，rpmalloc 亦能直接替换程序中的 malloc、calloc、realloc、free 函数，从而解决程序内存碎片化、内存申请和释放性能过低的问题。

通过定义 MMU_USE_RPMALLOC 可以开启 rpmalloc 功能，MMU 模块的内存申请和释放都将使用 rpmalloc 来完成。

rpmalloc 模块开启后编译约增加 50KB 的文件大小（mingw gcc 14.2），可使内存申请释放性能提升数倍乃至更多，但某些情况下可能会导致性能倒退，请测试后斟酌是否使用。

rpmalloc 作者为 Mattias Jansson，代码发布至公共领域授权。

rpmalloc github 地址：https://github.com/mjansson/rpmalloc

## 4. Struct Memory Management Unit

SMMU 为结构体内存管理器，功能相当于结构体数组，但是提供了 插入、交换、删除、排序 等功能，且基于自增长缓冲区的方式，提升了运行效率，使操作不需要反复申请内存。

SMMU 可以很好的替代结构体数组，但数组天生的缺陷是无法避免的，例如插入、删除效率很低，查询性能不足的问题。

SMMU 可用于管理需要高效遍历的内容，例如游戏中的渲染列表、UI渲染列表等，数组元素的访问仅相当于一次指针偏移，性能非常高。

## 5. Point Memory Management Unit

PMMU 模块与 SMMU 模块类似，都是代替数组的功能，但 PMMU 主要用于管理指针，而 SMMU 是管理结构体的，SMMU 可以替代 PMMU 的功能，但在只需要指针数组管理的场合，使用 SMMU 需要先定义一个结构体，每次操作都必须获取结构体指针，再取得结构体内的指针成员，这个流程非常麻烦。

而使用 PMMU 则很方便，可以直接读取或写入指定位置的指针值，不需要经过一层结构体指针传递，因此在管理指针引用数组的情况下，PMMU 会非常方便。

例如创建一个结构体引用集合，结构体数据池使用 MM256 或 SMMU 管理，指针引用则可以使用 PMMU 管理，事实上 MMU 库的子模块，包括 MM256、动态栈（SDSTK、PDSTK）、链表等许多结构内的分页数据，都是使用 PMMU 模块进行管理的。

## 6. Memory Buffer Management Unit

MBMU 内存缓冲区管理单元相当于 StringBuffer 或 StringBuilder 的功能，为高效拼接字符串而生，基于自增长缓冲区的方式，可以避免反复内存申请释放导致字符串拼接带来的性能下降。

MBMU 可用于各种编码的字符串处理（ANSI、GBK、UTF-8、UTF-16、UTF-32），字符串模式下会自动添加末尾的 \0（ANSI、GBK、UTF-8） 或 \0\0（UTF-16） 或 \0\0\0\0（UTF-32），或直接处理二进制数据（内部基于长度管理数据，而不是基于 \0 管理数据）。

## 7. Memory Management Unit 256

MMU256 是一个基础模块，它仅提供了多 256 个结构体的管理能力（可申请或释放256个结构体单元的内存）。

一般情况下，你应该不会考虑在程序中使用它，它存在的目的，主要是作为阵列单元使用，在 MM256 模块中，可以创建非常多个 MMU256，从而实现支持动态增长缩减的结构体内存池。

MMU256 可以让结构体内存申请和释放的时间变为一个固定指令周期，从而大大提升结构体内存的申请与释放速度。

## 8. Memory Management Unit 64K

MMU64K 功能与 MMU256 类似，唯一的区别在于，一个 MMU64K 管理单元可以管理最多 65536 个结构体。

假设一个结构体大小为 100 个字节，MMU256 管理这个结构体所需的内存为 256 * 100 + 约280 字节；而 MMU64K 管理这个结构体所需的内存则为 65536 * 100 + 约65560 字节。

当有大量结构体需要缓冲管理的时候，MMU64K性能更好，但占用内存更多。

因此可以根据需要（速度和内存占用哪一个更重要），来选择不同的管理器类型（MMU许多模块选择MM256来管理内存，以降低内存浪费）。

## 9. Memory Management 256

MM256 是基于 MMU256 阵列实现的内存池管理器，它的原理就是通过 PMMU 管理很多个 MMU256，申请结构体内存时会遍历选择一个空闲的 MMU256 管理单元申请一块内存，释放结构体内存时会通过内存前缀头获取对应的 MMU256 管理单元，通知它将内存回收。

当管理中已申请的 MMU256 管理单元数据满了时，会自动申请新的 MMU256 扩容，理论上 MM256 最大可以管理10亿个以上的结构体内存。

MM256 可以极大提升结构体内存申请和释放效率，适合用于需要管理大量结构体数据的场景，例如 MMU 的哈希表、链表、二叉树等模块，都基于 MM256 来管理结构体内存。

MM256 依靠 MMU256 阵列管理内存的申请和释放，因此当管理器内 MMU256 的阵列数量过多时，效率会降低（循环查找空闲的MMU256单元导致），可使用 MM64K 改善这个情况，多数时候不需要，除非数据量以十万计。

## 10. Memory Management 64K

MM64K 与 MM256 功能类似，区别在于它使用 MMU64K 阵列作为内存管理单元，以更多的内存浪费为代价，可以提升元素极多状态下的运行速度。

MM64K 与 MM256 最大都可以管理 10 亿个结构体内存，两者在这方面并没有区别。

## 11. Struct Static Stack

SSSTK 为结构体静态栈，初始化时指定栈的最大容量，会一次性申请足够容纳所有成员的内存。

静态栈的效率很高（相当于数组），但不能根据需要随时扩容。

请注意这里的栈是建立在内存堆上的，性能并不能和调用栈相提并论，主要用于栈这个抽象数据结构使用，SSSTK 可以管理固定长度的结构体，因此适合需要对数据进行分层处理的场合，例如编译器语句结构深度的管理。

## 12. Point Static Stack

PSSTK 为指针静态栈，功能和 SSSTK 类似，区别在于它管理的不是结构体，而是指针，可参考 SMMU 和 PMMU 的区别。

## 13. Struct Dynamic Stack

SDSTK 为结构体动态韩，它使用 MM256 管理内存，初始化时不需要指定栈容量，而是在使用时根据需要随时扩容和缩减，这样我们就不需要操心栈的内存管理了，不用担心爆栈的情况（当然无限递归的后果也可能是爆内存）。

和 SSSTK 一样，这只是一个建立在堆内存上的抽象数据结构，用于管理固定长度的结构体使用。

## 14. Point Dynamic Stack

PDSTK 为指针动态栈，功能和 SDSTK 类似，区别在于它管理的是指针而不是结构体。

## 15. Linked List

LLIST 为双向链表，双向链表具备极佳的插入、删除性能，但遍历和查询性能很低，和其他模块一样，MMU 的 LLIST 模块除了作为链表使用之外，更关键的作用是管理链表内数据结构的内存，它使用 MM256 管理内存。

## 16. AVLTree

AVLTree 为平衡二叉树，二叉树在 插入、删除、查询、遍历 等性能上取得了非常好的平衡，而平衡二叉树最擅长的是数据查询，理论上它可以在10次循环内，从40亿个数据中找到所需的数据。

平衡二叉树和红黑树主要的区别在于，红黑树更重视插入、删除的性能，而平衡二叉树更重视查找的性能。

AVLTree 使用 MM256 管理内存。

## 17. Red Black Tree

RBTree 为红黑树，特点和 AVLTree 类似，红黑树有更好的数据插入删除性能，数据查询性能较差，选择取舍的关键，在于数据是读多（用AVLTree）还是写多（用RBTree）。

RBTree 使用 MM256 管理内存。

## 18. nmhash32x

nmhash32x 是性能非常优秀的 32 位哈希算法，无论是 Hash 速度，还是碰撞特性都非常好，MMU 选择使用这种算法作为 Hash Table 的实现算法，你也可以单独使用这种算法进行哈希值计算。

nmhash32x 基于 BSD2 协议开源，源代码中已附带开源许可证。

## 19. rapidhash

rapidhash 是性能非常优秀的 64 位哈希算法，无论是 Hash 速度，还是碰撞特性都非常好，MMU 选择使用这种算法作为 Hash Table 的实现算法，你也可以单独使用这种算法进行哈希值计算。

rapidhash 基于 BSD2 协议开源，源代码中已附带开源许可证。

## 20. AVLTree Hash Table 32

AVLHT32 为基于 32位哈希算法 + AVLTree 实现的哈希表，二叉树具备非常强悍的查询性能，优秀的插入、删除性能，是制作哈希表的终极选择，搭配 32 位哈希算法，节约单元数据的内存。

通常四种哈希表根据使用需要选择一种即可。

## 21. AVLTree Hash Table 64

AVLHT64 为基于 64位哈希算法 + AVLTree 实现的哈希表，二叉树具备非常强悍的查询性能，优秀的插入、删除性能，是制作哈希表的终极选择，搭配 64 位哈希算法，有效减少了数据碰撞的可能性。

通常四种哈希表根据使用需要选择一种即可。

## 22. RBTree Hash Table 32

RBHT32 为基于 32位哈希算法 + RBTree 实现的哈希表，二叉树具备非常强悍的查询性能，优秀的插入、删除性能，是制作哈希表的终极选择，搭配 32 位哈希算法，节约单元数据的内存。

通常四种哈希表根据使用需要选择一种即可。

## 23. RBTree Hash Table 64

RBHT64 为基于 64位哈希算法 + RBTree 实现的哈希表，二叉树具备非常强悍的查询性能，优秀的插入、删除性能，是制作哈希表的终极选择，搭配 64 位哈希算法，有效减少了数据碰撞的可能性。

通常四种哈希表根据使用需要选择一种即可。

## 24. 待实现功能（后续计划）

#### 完善使用文档

尽管 MMU 模块并不复杂，且头文件内功能定义清晰，又提供了完整的测试代码，但由于没有使用文档，还是需要很多时间来阅读代码学习如何使用它。

#### Circular Sequence Queue 循环顺序队列

#### Elastic Expansion Queue 弹性扩展队列 [使用 MM256 管理内存]

#### Priority Queue 优先级队列 [使用红黑树实现]

#### Directed Graph 单向图结构

#### Undirected Graph 双向图结构

#### Document Object Model 通用文档对象模型

……

更多功能需求可以私信联系作者进行开发或集成，欢迎提交合并请求

作者邮箱：xywhsoft@qq.com